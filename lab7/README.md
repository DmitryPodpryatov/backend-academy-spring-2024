# Семинар 7. Retry, CB

> Поднимаем зависимости

```shell
docker-compose up
```

Сегодня всё довольно просто на словах, однако на деле могут возникнуть сложности при реализации.

### #1 Retry

Мы живем не в идеальном мире (к сожалению или к счастью), поэтому не все запросы отрабатывают идеально. И как раз в
таких случаях, когда что-то пошло не так, на помощь приходят ретраи.

Концепция очень простая — поймали ошибку — ретраим. Поймали еще одну, продолжаем ретраить. И так или пока мы не получим
ответ, который нас удовлетворит, или когда количество ретраев достигнет какого-то заранее заданного порога.

Бесконечные ретраи — очень сомнительное решение, потому что таким образом мы можем положить как сервис, к которому мы
обращаемся, так и нас самих, забив пулы потоков задачами.

Типичный вопрос, когда речь заходит о ретраях — в каких ситуациях (или при каких кодах ответа) мы хотим ретраить —
предлагаю вам подумать над этим самостоятельно.

Ретраи так же можно делать с определенной задержкой по времени, обычно применяет exponential _backoff_, когда каждый
новый ретрай производится с задержкой, умноженной на коеффициент в степени попытки (т.е. допустим 1с, 2с, 4с, 8с, 16с,
...)

Так же если у вас много запросов к одному сервису, чтобы его случайно не положить в случае, когда ретраи
синхронизируются друг с другом,
применяется [jitter](https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter) — случайная
величина, которая прибавляется к задержке.

---

1. А сама задача заключается в том, чтобы написать метод `retry`
   из [Retry.scala](src/main/scala/lab7/services/Retry.scala) и прикрутить его к вызову запроса в HTTP клиенте

---

### #2 Circuit Breaker

В случаях, когда внешний сервис лежит и не поднимается, делать ретраи бесполезно. Мы не только не получим ответ с
большой вероятностью, но еще и не делаем коллегам ничего хорошего, осыпая их запросами.

Тогда мы можем отследить количество ошибок на сервисе и "вырубить рубильник", частично или польностью отключив запросы.
А через какое-то время вернуть полный функционал.

Сам по себе CB представляет из себя конечный автомат, поэтому нам достаточно описать все состояния и переходы между ними.

---

1. Написать реализацию [CircuitBreaker.scala](src/main/scala/lab7/services/CircuitBreaker.scala) и прикрутить его к
   вызову запроса в HTTP клиенте

---

- https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker
